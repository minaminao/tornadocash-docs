# Core Deposit Circuit

コアとなるデポジット回路は、多くのユーザーが利用するもので、ユーザーがある資産額のデポジットを表すコミットメントを作成したこと、その資産をまだ引き出していないこと、最初のコミットメントを作成したときに提供した秘密を知っていることを証明するものです。

## Making a Deposit

Tornado Cashへのデポジットは非常にシンプルな操作で、実際にはZKの証明は必要ありません。少なくともまだ必要ありません。デポジットを行うには、[Tornadoコントラクト](https://github.com/tornadocash/tornado-core/blob/master/contracts/Tornado.sol)インスタンスの`deposit`メソッドを呼び出し、デポジットする資産額とともに[Pedersenコミットメント](https://crypto.stackexchange.com/questions/64437/what-is-a-pedersen-commitment)を与えます。このコミットメントは専用の[Merkleツリー](https://en.wikipedia.org/wiki/Merkle_tree)に挿入され、BN128楕円曲線のオーダーの素数に関連する楕円曲線にMerkleツリーの構造が合わせられ、ツリーのラベルはMiMCハッシュで計算されます。

### Commitment Scheme

暗号の文脈で「コミットメント」をするとき、あなたがしていることは、秘密の値（多くの場合、大きくてランダム）を取って、何らかの暗号関数（例えば、ハッシュ関数）にかけ、その結果を公開することです。その後、コミットメントを実行する必要があるときに、元の秘密値を知っていることを証明します。

これは[コミットメントスキーム](https://en.wikipedia.org/wiki/Commitment_scheme)と呼ばれるものです。

### Pedersen Hash

[Pedersenハッシュ](https://iden3-docs.readthedocs.io/en/latest/iden3_repos/research/publications/zkproof-standards-workshop-2/pedersen-hash/pedersen.html)は極めて特殊なハッシュ関数で、特にゼロ知識証明回路を活用したアプリケーションに適している。SHA-256のような他のハッシュ関数が、わずかな入力の違いでも非常に異なる出力を生成するような性質（[avalanche effect](https://en.wikipedia.org/wiki/Avalanche_effect)）を持つように設計されているのに対し、Pedersenハッシュはゼロ知識証明回路において非常に効率的にハッシュを計算することを優先している。

Pedersenでメッセージをハッシュ化すると、メッセージのビットが[Baby Jubjub](https://github.com/barryWhiteHat/baby_jubjub)という[楕円曲線](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)に沿った点まで圧縮されます。Baby Jubjubは、[EIP-196](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md)で追加されたEthereumネットワーク上のプリコンパイルされた操作でサポートされているBN128楕円曲線のオーダーにあります。つまり、PedersenハッシュのようなBaby Jubjub曲線を利用した演算は、ガス効率が高いのです。

メッセージのPedersenハッシュを計算するとき、その楕円曲線に沿った結果のポイントは、検証には非常に効率的ですが、元のメッセージに逆戻りさせることは不可能です。

### Tornado Commitment
Tornado Cashの入金に対するコミットメントを生成するために、まず、それぞれ31バイト長の2つの大きなランダムな整数を生成します。最初の値は、後で預金を引き出すために開示するnullifierであり、2番目は預金と引き出しの間の機密関係を確保するためのシークレットです。

入金メモのプリイメージはこれら2つの値(`nullifier` + `secret`)を連結したものであり、長さ62バイトのメッセージとなります。このメッセージはPedersenハッシュ化され、32バイトのビッグエンディアン整数としてエンコードされたBaby Jubjub楕円曲線の要素を表す出力とします。

これをコード形式で見たい場合は、[tornado-cliのデポジット関数](https://github.com/tornadocash/tornado-cli/blob/master/cli.js#L53-L112)を参照すればよいです。

### MiMC Merkle Tree
[Tornadoコントラクト](https://github.com/tornadocash/tornado-core/blob/master/contracts/Tornado.sol)は、MiMCハッシュを使用してノードのラベル付けを行う[Merkleツリー](https://en.wikipedia.org/wiki/Merkle_tree)に特化したものです。

Merkle木を知らない人のために説明すると、非リーフノードにはその子ノードのラベルのハッシュが、リーフノードにはそのデータのハッシュがラベル付けされている二分木である。通常、Merkle木はSHA-2などの一方向暗号ハッシュ関数を用いるが、今回はいくつかの有用な特性を持つMiMCを用いている。

ゼロ知識証明は基本的に素数体に基づいており、PedersenハッシュはBaby Jubjub楕円曲線によって定義される素数体内の点であり、これはEthereumでネイティブにサポートされるBN128曲線のオーダー内であることから、MiMCの有用な特性の1つは、素数体での動作に適していることです。ゼロ知識証明は運用コストが高く、Ethereumトランザクションにおける各操作にはそれに応じたガスコストがかかるため、私たちが設計する特定の種類の操作は、可能な限りガス効率を高める必要があります。

このほか、MiMCの特に有用な特性として、「非並列化可能」「計算は難しいが検証は簡単」というものがある。これらの特性により、Merkle木の中で衝突する経路を持つ偽造された「約束」を計算することは、計算上不可能になり、契約の安全性が高められる。

### Zero Nodes

Tornado Merkle Treeの初期化において、木の高さをカバーする単一のパスが、`keccak256("tornado") % FIELD_SIZE`のラベルを持つ「ゼロリーフ」ノードから始まるようにあらかじめ割り当てられています。根に向かう後続の非葉ノードには、あたかも木の底部全体が同じ葉ノードで占められているかのようなラベルが付けられます。

この「ゼロノード」の目的は、有効なコミットメントで終了するまでは、Merkleツリー内のすべての経路が無効であることを保証することです。

### Inserting a Commitment

TornadoコントラクトのMerkleツリーにコミットを挿入する場合、「ゼロリーフ」をPedersenコミットのMiMCハッシュをラベルとする新しいリーフに置き換え、さらにツリーをトラバースして、新しいリーフが下に紹介するラベル更新に基づいて新しいラベルを各その後の親ノードで更新することになります。

コミットメントはツリー内で左から右へ挿入され、2つのコミットメントの挿入ごとに「サブツリー」が満たされる。各挿入は木の「インデックス」を増加させ、次のコミットメントがそのMerkleパスのエントリーの左側と右側のどちらに挿入されるかを決定します。

入金によってツリーが更新されると、最上位のノードのラベルがツリーの新しい「ルート」になり、過去100個のルートのラベルを含むローリングヒストリーに追加され、後の出金処理に使用されます。

Tornado Cashの入金コントラクトは20の「レベル」で展開され、各レベルは潜在的な葉の数を2のべき乗で増やしている。つまり、契約のMerkle木は最大2^20葉までサポートしており、交換が必要になるまでに最大1,048,576件の入金が可能であることを意味している。

このようにレベル数が少ないように見えるのは、入金ごとにレベルの数だけツリーを更新しなければならないからである。レベル数が多いツリーでは、入金ごとに必要なガス量が多くなり、紙幣の引き出し時に必要なプルーフサイズも大きくなります。

## Making a Withdrawal

預金をしたことで、あなたは今、証明の根拠となる真実の主張の集合を手に入れた。一般に、ゼロ知識証明は、証明者と検証者の双方が知っている何らかの値に固定され、それに対して、証明者のみが知っている値の集合との関係を証明しようとするものである。回路検証者は、証明者が既知の値を使用し、その値が計算された証明が回路の制約を満たすことを確認することができる。

### Inputs to a Withdrawal Proof

Tornado.cashの入金の場合、証明者（出金取引を行う人）と検証者（入金契約の出金方法）の両方が最近のMerkleルートを知っている。証明者は、証明の生成に使用した他の公開入力のセットも提供する。

#### The total set of public inputs for a withdrawal proof are:
1. 最近のMerkleルート
2. デポジットコミットメントからのnullifierコンポーネントのペダーセンハッシュ
3. 引き出しの受取人のアドレス
4. 相手が選択したリレイヤーのアドレス（または自分のアドレス）
5. リレイヤーに支払っている料金（もしくは0円）
6. リレイヤーに支払っている返金額（もしくは0円）

#### The additional private inputs for a withdrawal proof are:

1. デポジットコミットメントからnullifierコンポーネントを
2. デポジットコミットメントに含まれる秘密の成分
3. Merkleツリールートとリーフノード間の経路に存在するノードラベルの集合
4. 指定された各パス要素が、親ノードの左側にあるか右側にあるかを示す `0/1` 値の配列。

### Proven Claims
コミットメントを構築し、merkle treeに挿入したときに、私たちが新たに作り出した巧妙な知識を見逃すのは簡単なことでしょう。撤退するためには、Pedersenコミットメントの構成要素を知っていることを証明するだけで、merkle木はそのコミットメントハッシュを格納する効率的な方法に過ぎないと考える傾向があるかもしれません。

この構成が特別なのは、単に預託されたコミットメントの構成要素を知っているというだけでなく、コミットメントの前像から始まる**know the path to a commitment within the tree**、**how to get there**を単純に証明できることです。

もし私たちが預けたハッシュの前景像を知っていることを証明するだけなら、どのコミットメントが私たちのものかを明らかにする危険があります。その代わりに、私たちはコミットメントの前景を公開するのではなく、単に木の中のコミットメントの前景を知っていることを証明しているのです。どのコミットメントが私たちのものかは、回路プロトコルの引き出し側では全く区別がつかないままです。

### Computing the Witness
**Nullifier Hash Check**

引き出し証明の証人を計算するために、この回路はまず私的な預託約束入力（`nullifier` + `secret`）を受け取り、完全な約束メッセージのPedersenハッシュと、nullifierだけのPedersenハッシュを同時に計算する回路部品を通して実行される。その後、回路は結果のnullifierハッシュと公開入力として提供されたものを比較し、それらの等価性を主張する。

**This proves that the nullifier hash that you supplied publicly is in fact a component of your original commitment.**

**Merkle Tree Check**

次に、計算したコミットメントハッシュ、公開で指定したmerkle root、非公開で指定したパス要素や左右のセレクタを入力として、merkle treeのパス主張をチェックする回路を構成します。

Merkle Tree チェッカーは、コミットメントハッシュと提案されたパスの最初の要素を Muxer に入力し、パスの一番下から開始されます。Muxerは3番目の入力として、指定された左右の方向から1つの要素を受け取ります。Muxerコンポーネントは、これらの方向を使用して、MiMCハッシュコンポーネントにその入力の順序を通知します。与えられた方向が 0 の場合、与えられたパス要素が左側にあり、コミットメントハッシュが右側にあります。もし方向が1であれば、順序は逆になります。

MiMCハッシャーは結果のハッシュを出力し、Merkle Tree Checkerは次のレベルへ進む。今回は、コミットメントハッシュの代わりに、最後のレベルのハッシュを使用することを除いて、最後の処理を繰り返す。そして、最終的なハッシュの出力が得られるまで、提案されたパスの各レベルを実行し続ける。

Merkle Tree Checkerは、計算したハッシュと入力された公開Merkle ルートを比較し、両者が等しいことを主張する。

**This proves that your commitment exists within some path beneath the specified merkle root.**

**Extra Withdrawal Parameter Check**

終了する前に、回路は残りの4つの公開入力をそれぞれ取り、それらを2乗して公開出力とする。これは厳密には必要ないのだが、出金処理が行われる前に取引パラメータが改ざんされないように、証明の中に一連の制約を作り出すのである。もし、これらのパラメータのいずれかが変更された場合、あなたの証明はもはや有効ではないだろう。

### Computing the Proof
証明の証人ができたので、その証人の状態値をWithdrawal回路に対応するR1CSに入力し、その上で証明器を走らせます。証明器からは、2つの証明の成果物が出てくる。1つはSNARKプロトコルによる証明、もう1つはその証明に対応する公開入出力の集合である。

### Completing a Withdrawal Transaction
出金証明を作成したら、その証明と公開入力を、入金契約の`withdraw`メソッドに供給します。このメソッドは次のことを検証する。

1. 指定されたリレイヤー手数料が、出金する資産の額面金額を超えないこと。
2. 与えられたnullifierハッシュが以前に使用されたことがない
3. 供給されたMerkleルートは、100根の履歴を使用して、既知のものです
4. 提供された証明は有効である

預金コントラクトの依存関係として配備された成果物の1つは、Withdrawal回路の証明キーを入力として使用して生成されるSolidityコントラクトである。この検証コントラクトは、1つのパブリックビュー関数を持つ最適化された証明検証器であり、証明と6つのパブリック入力の配列を`uint256`値として受け入れる。

この関数は、公開された入力にしたがって証明が有効であれば、`TRUE` を返す。

上記前提条件が満たされた場合、供給されたnullifierハッシュを使用済みnullifierセットに挿入し、指定された料金パラメータに従って、受信者とリレイヤーの間で預託金の値を分配する。


# コアデポジットコントラクト

コアとなるデポジット回路は多くのユーザーが利用するもので、ユーザーがある資産額のデポジットを表すコミットメントを作成したこと、その資産をまだ引き出していないこと、最初のコミットメントを作成したときに与えた秘密を知っていることを証明するものです。

## デポジットの作成

Tornado Cashへのデポジットはとてもシンプルな操作で、実際にはZKの証明は必要ありません。少なくともまだ必要ありません。デポジットを行うには、[Tornadoコントラクト](https://github.com/tornadocash/tornado-core/blob/master/contracts/Tornado.sol)インスタンスの`deposit`メソッドを呼び出し、デポジットする資産額とともに[Pedersenコミットメント](https://crypto.stackexchange.com/questions/64437/what-is-a-pedersen-commitment)を与えます。このコミットメントは専用の[Merkleツリー](https://en.wikipedia.org/wiki/Merkle_tree)に挿入されます。このMerkleツリーの構造は、BN128楕円曲線のオーダーの素数に関連する楕円曲線に合わせられており、ツリーのラベルはMiMCハッシュで計算されます。

### コミットメントスキーム

暗号の文脈で「コミットメント」をするとは具体的には、秘密の値（多くの場合、大きくてランダムなもの）を選んで何らかの暗号学的関数（例えばハッシュ関数）にかけてその結果を公開することです。その後、コミットメントを実行する必要があるときに元の秘密の値を知っていることを証明します。

これは[コミットメントスキーム](https://en.wikipedia.org/wiki/Commitment_scheme)と呼ばれるものです。

### Pedersenハッシュ

[Pedersenハッシュ](https://iden3-docs.readthedocs.io/en/latest/iden3_repos/research/publications/zkproof-standards-workshop-2/pedersen-hash/pedersen.html)は極めて特殊なハッシュ関数で、特にゼロ知識証明回路を活用したアプリケーションに適しています。SHA-256のような他のハッシュ関数が、わずかな入力の違いでも全く異なる出力を生成するような性質（[アバランチ効果](https://en.wikipedia.org/wiki/Avalanche_effect)）を持つように設計されているのに対し、Pedersenハッシュはゼロ知識証明回路において非常に効率的にハッシュを計算できることを優先しています。

Pedersenでメッセージをハッシュ化すると、メッセージのビットが[Baby Jubjub](https://github.com/barryWhiteHat/baby_jubjub)という[楕円曲線](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)に沿った点まで圧縮されます。Baby Jubjubは、[EIP-196](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-196.md)で追加されたEthereumネットワーク上のプリコンパイルされた関数でサポートされているBN128楕円曲線のオーダーにあります。つまり、PedersenハッシュのようなBaby Jubjub曲線を利用した演算はガス効率が高いのです。

メッセージのPedersenハッシュを計算するとき、その楕円曲線に沿った結果のポイントは、検証には非常に効率的ですが、元のメッセージを逆算することは不可能です。

### Tornadoコミットメント

Tornado Cashのデポジットに対するコミットメントを生成するために、まずそれぞれ31バイト長の2つの大きなランダムな整数を生成します。最初の値は、後でデポジットを引き出すために開示するnullifierであり、2番目の値はデポジットと引き出しの間の機密関係を確保するためのシークレットです。

デポジットノートのプリイメージはこれら2つの値（`nullifier` + `secret`）を連結したものであり、長さ62バイトのメッセージとなります。このメッセージがPedersenハッシュ化され、32バイトのビッグエンディアンの整数としてエンコードされたBaby Jubjub楕円曲線の要素となって出力されます。

これをコード形式で見たい場合は、[tornado-cliのデポジット関数](https://github.com/tornadocash/tornado-cli/blob/master/cli.js#L53-L112)を参照してください。

### MiMC Merkleツリー

[Tornadoコントラクト](https://github.com/tornadocash/tornado-core/blob/master/contracts/Tornado.sol)は、MiMCハッシュを使用してノードのラベル付けを行う[Merkleツリー](https://en.wikipedia.org/wiki/Merkle_tree)に特化したものです。

Merkleツリーを知らない人のために説明すると、非リーフノードにはその子ノードのラベルのハッシュが、リーフノードにはそのデータのハッシュがラベル付けされている二分木です。通常、MerkleツリーはSHA-2などの一方向の暗号学的ハッシュ関数を用いますが、Tornado Cashではいくつかの有用な特性を持つMiMCを用いています。

MiMCの有用な特性の1つは、素数体での動作に適していることです。これはゼロ知識証明は基本的に素数体に基づいており、PedersenハッシュはBaby Jubjub楕円曲線によって定義される素数体内の点である（EthereumでネイティブにサポートされるBN128曲線のオーダー内）ことから重要です。ゼロ知識証明は運用コストが高く、Ethereumトランザクションにおける各操作にはそれに応じたガスコストがかかるため、私たちが設計する特定の種類の操作は、可能な限りガス効率を高める必要があります。

このほかMiMCの特に有用な特性として、「非並列化可能」「計算は難しいが検証は簡単」というものがあります。これらの特性により、Merkleツリーの中で衝突する経路を持つ偽造された「コミットメント」を計算することは計算上不可能になり、コントラクトの安全性が高められます。

### ゼロノード

Tornado Merkleツリーの初期化中に、`keccak256("tornado") % FIELD_SIZE`のラベルを持つ「ゼロリーフ」ノードから始まる、木の高さ方向の単一のパスが割り当てられます。ルートに向かって続く非リーフノードには、あたかも木の底全体が同じリーフノードで占められているかのようなラベルが付けられます。

この「ゼロノード」の目的は、有効なコミットメントで終了するまでは、Merkleツリー内のすべてのパスが無効であることを保証することです。

### コミットメントの挿入

TornadoコントラクトのMerkleツリーにコミットを挿入する場合、「ゼロリーフ」をPedersenコミットのMiMCハッシュをラベルとする新しいリーフに置き換え、さらにツリーをトラバースして、新しいリーフが下に紹介するラベル更新に基づいて新しいラベルを各その後の親ノードで更新することになります。

コミットメントはツリー内で左から右へ挿入され、2つのコミットメントの挿入ごとに「サブツリー」が満たされます。各挿入は木の「インデックス」を増加させ、次のコミットメントがそのMerkleパスのエントリーの左側と右側のどちらに挿入されるかを決定します。

デポジットによってツリーが更新されると、最上位のノードのラベルがツリーの新しい「ルート」になり、過去100個のルートのラベルを含むローリングヒストリーに追加され、後の出金処理に使用されます。

Tornado Cashのデポジットコントラクトは20の「レベル」でデプロイされ、各レベルは潜在的なリーフの数を2のべき乗で増やしている。つまり、コントラクトのMerkleツリーは最大2^20個のリーフをサポートしており、交換が必要になるまでに最大1,048,576件のデポジットが可能であることを意味している。

このようにレベル数が少ないように見えるのは、デポジットごとにレベルの数だけツリーを更新しなければならないからです。レベル数が多いツリーでは、デポジットごとに必要なガス量が多くなり、ノートの引き出し時に必要なプルーフサイズも大きくなります。

## 出金の作成

デポジットをしたことで、あなたは今、証明の根拠となる真実の主張の集合を手に入れました。一般に、ゼロ知識証明は証明者と検証者の双方が知っている何らかの値に固定され、それに対して証明者のみが知っている値の集合との関係を証明しようとするものです。回路検証者は、証明者が既知の値を使用し、その値が計算された証明が回路の制約を満たすことを確認できます。

### Inputs to a Withdrawal Proof

Tornado Cashの入金の場合、証明者（出金取引を行う人）と検証者（デポジットコントラクトの出金方法）の両方が直近のMerkleルートを知っています。証明者は証明の生成に使用した他の公開入力の集合も提供します。

#### 出金証明のためのパブリックな入力の集合は以下の通り:

1. 最近のMerkleルート
2. デポジットコミットメントからのnullifierコンポーネントのPedersenハッシュ
3. 引き出しの受取人のアドレス
4. 受取人が選択したリレイヤーのアドレス（または受取人自身のアドレス）
5. リレイヤーに支払っている料金（もしくは0）
6. リレイヤーに支払っている返金額（もしくは0）

#### 出金証明のための追加のプライベートな入力は以下の通り:

1. デポジットコミットメントからのnullifierコンポーネント
2. デポジットコミットメントに含まれる秘密の要素
3. Merkleツリールートとリーフノード間の経路に存在するノードラベルの集合
4. 指定された各パス要素が、親ノードの左側にあるか右側にあるかを示す `0/1` 値の配列

### Proven Claims

コミットメントを構築しMerkleツリーに挿入したときに、私たちが新たに作り出した巧妙な知識を見逃すのは簡単なことでしょう。出金するためには、Pedersenコミットメントの構成要素を知っていることを証明するだけで、Merkleツリーはそのコミットメントハッシュを格納する効率的な方法に過ぎないと考える傾向があるかもしれません。

この構成が特別なのは、単にデポジットされたコミットメントの構成要素を知っているというだけでなく、**木の中のコミットメントへのパスと、コミットメントのプリイメージから始めてそこにたどり着く方法を知っている**ことを、簡単に証明できる点です。

もし私たちが預けたハッシュのプリイメージを知っていることを証明するだけなら、どのコミットメントが私たちのものかを明らかにする危険があります。その代わりに、私たちはコミットメントのプリイメージを公開するのではなく、単に木の中のコミットメントのプリイメージを知っていることを証明しているのです。どのコミットメントが私たちのものかは、回路プロトコルの出金側では全く区別がつかないままです。

### Witnessの計算

**Nullifierハッシュチェック**

出金証明のwitnessを計算するために、この回路はまずプライベートなデポジットコミットメントの入力（`nullifier` + `secret`）を受け取り、完全なコミットメントメッセージのPedersenハッシュと、nullifierだけのPedersenハッシュを同時に計算する回路部品を通して実行されます。その後、回路は結果のnullifierハッシュとパブリックな入力として提供されたものを比較し、それらの等価性を主張します。

**これは、あなたが公に提供したnullifierハッシュが、実際にはあなたのオリジナルのコミットメントの構成要素であることを証明するものです。**

**Merkleツリーチェック**

次に、計算したコミットメントハッシュ、公開で指定したMerkleルート、非公開で指定したパス要素や左右のセレクタを入力として、Merkleツリーのパス主張をチェックする回路を構成します。

Merkleツリーチェッカーは、コミットメントハッシュと提案されたパスの最初の要素をミキサーに入力し、パスの一番下から開始されます。ミキサーは3番目の入力として、指定された左右の方向から1つの要素を受け取ります。ミキサーコンポーネントは、これらの方向を使用して、MiMCハッシュコンポーネントにその入力の順序を通知します。与えられた方向が0の場合、与えられたパス要素が左側にあり、コミットメントハッシュが右側にあります。もし方向が1であれば、順序は逆になります。

MiMCハッシャーは結果のハッシュを出力し、Merkleツリーチェッカーは次のレベルへ進みます。今回は、コミットメントハッシュの代わりに、最後のレベルのハッシュを使用することを除いて、最後の処理を繰り返す。そして、最終的なハッシュの出力が得られるまで、提案されたパスの各レベルを実行し続ける。

Merkleツリーチェッカーは、計算したハッシュと入力された公開Merkleルートを比較し、両者が等しいことを主張します。

**これは、あなたのコミットメントが指定されたMerkleルートの下のパスに存在することを証明するものです。**

**追加の出金パラメーターチェック**

終了する前に、回路は残りの4つの公開入力をそれぞれ取り、それらを2乗して公開出力とします。これは厳密には必要ありませんが、出金処理が行われる前にトランザクションパラメータが改竄されないように、証明の中に一連の制約を作り出すのです。もし、これらのパラメータのいずれかが変更された場合、あなたの証明はもはや有効ではないでしょう。

### 証明の計算C
証明のwitnessができたので、そのwitnessの状態値をWithdrawal回路に対応するR1CSに入力し、その上で証明器を走らせます。証明器からは、2つの証明の成果物が出てきます。1つはSNARKプロトコルによる証明、もう1つはその証明に対応する公開入出力の集合です。

### 出金トランザクションの完了
出金証明を作成したら、その証明と公開入力を、デポジットコントラクトの`withdraw`メソッドに供給します。このメソッドは次のことを検証します。

1. 指定されたリレイヤー手数料が出金する資産の額面金額を超えないこと
2. 与えられたnullifierハッシュが以前に使用されたことがないこと
3. 供給されたMerkleルートは100個の履歴を使用して既知のものであること
4. 提供された証明は有効であること

デポジットコントラクトの依存関係として配備された成果物の1つは、Withdrawal回路の証明キーを入力として使用して生成されるSolidityコントラクトです。この検証コントラクトは、1つのパブリックビュー関数を持つ最適化された証明検証器であり、証明と6つのパブリック入力の配列を`uint256`値として受け入れます。

この関数は、公開された入力にしたがって証明が有効であれば、`TRUE` を返します。

上記前提条件が満たされた場合、供給されたnullifierハッシュを使用済みnullifier集合に挿入し、指定された料金パラメータに従って、受信者とリレイヤーの間でデポジットの値を分配します。

